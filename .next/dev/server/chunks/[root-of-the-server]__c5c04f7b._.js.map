{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///home/kanata/calenderapp/app/api/ocr/route.ts"],"sourcesContent":["// app/api/ocr/route.ts\n\nimport { NextRequest, NextResponse } from \"next/server\";\n// Anthropic SDK is dynamically imported inside the handler to avoid\n// build-time failures on platforms where the package cannot be resolved.\nimport fs from \"fs\";\nimport path from \"path\";\nimport os from \"os\";\nimport type { OCRResult, APIResponse } from \"@/lib/types\";\n\n// note: anthropic client will be created dynamically when needed\n\n// Helper: perform local Tesseract OCR on base64 image and return raw text\nasync function performTesseractOCR(base64Data: string) {\n  try {\n    const buffer = Buffer.from(base64Data, \"base64\");\n    const tmpDir = os.tmpdir();\n    const fileName = `ocr_input_${Date.now()}.png`;\n    const filePath = path.join(tmpDir, fileName);\n    await fs.promises.writeFile(filePath, buffer);\n\n    // dynamic import to avoid static types issues\n    const tesseract = await import(\"node-tesseract-ocr\");\n    const config = { lang: \"jpn+eng\", oem: 1, psm: 3 } as any;\n    const text = await tesseract.recognize(filePath, config);\n\n    // cleanup\n    try {\n      await fs.promises.unlink(filePath);\n    } catch {}\n\n    return text as string;\n  } catch (err) {\n    console.error(\"Tesseract OCR error:\", err);\n    throw err;\n  }\n}\n\nexport async function GET() {\n  return NextResponse.json({ success: true, data: [], info: \"OCR endpoint (POST) is available\" });\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    // Anthropic API キーがない場合は LLM をスキップして Tesseract フォールバックを使います\n    const hasAnthropicKey = !!process.env.ANTHROPIC_API_KEY;\n    if (!hasAnthropicKey) {\n      console.warn(\n        \"Anthropic API key not configured — will use local Tesseract fallback\"\n      );\n    }\n\n    const formData = await request.formData();\n    const image = formData.get(\"image\") as string;\n\n    if (!image) {\n      return NextResponse.json<APIResponse<null>>(\n        {\n          success: false,\n          error: \"画像がアップロードされていません\",\n        },\n        { status: 400 }\n      );\n    }\n\n    // Base64からmimeTypeとデータを抽出\n    const mimeTypeMatch = image.match(/data:([^;]+);/);\n    const mimeType = mimeTypeMatch ? mimeTypeMatch[1] : \"image/jpeg\";\n    const base64Data = image.split(\",\")[1] || image;\n\n    // 名前（フォームで渡された場合）\n    const name = (formData.get(\"name\") as string) || \"\";\n\n    // Claude APIで画像を解析\n    // 名前が渡されていれば、その名前に関連するシフトのみ抽出するよう指示を追加します。\n    const nameInstruction = name\n      ? `\\n\\n注意: 画像中に氏名や担当者名が記載されている場合は、名前が \"${name}\" に該当する予定（シフト）のみを抽出してください。該当がない場合は空配列を返してください。`\n      : \"\";\n\n    // より構造化されたJSONを返すようプロンプトを強化します。\n    const prompt =\n      `この画像からスケジュール・予定情報を抽出してください。\\n\\n必ず返す形式: JSON配列。配列の各要素は少なくとも title を含むオブジェクトで、可能なら以下フィールドを出力してください: date, startTime, endTime, title, description, category, assignedTo (配列), rawText (文字列)。assignedTo が空でも空配列を返してください。\\n\\n出力は\"JSONのみ\"にしてください。余計な説明や注釈、マークダウンは一切含めないでください。日付や時間が読み取れない場合は null を使用し、予定が無ければ空配列 [] を返してください。\\n\\n以下に複数の具体例を示します。必ず同じフィールド名で返してください。\\n\\n例1（複数名・日付あり）:\\n[\\n  {\\n    \"date\": \"2025-11-20\",\\n    \"startTime\": \"09:00\",\\n    \"endTime\": \"12:00\",\\n    \"title\": \"会議（営業部）\",\\n    \"description\": \"来期予算の打ち合わせ\",\\n    \"category\": \"work\",\\n    \"assignedTo\": [\"田中 太郎\", \"佐藤 花子\"],\\n    \"rawText\": \"11/20 9:00-12:00 田中/佐藤 会議 来期予算\"\\n  }\\n]\\n\\n例2（氏名が画像に明記され、該当者のみ抽出）:\\n[\\n  {\\n    \"date\": \"2025-11-21\",\\n    \"startTime\": \"14:00\",\\n    \"endTime\": \"15:00\",\\n    \"title\": \"面談\",\\n    \"description\": \"新人面談\",\\n    \"category\": \"work\",\\n    \"assignedTo\": [\"山田 太郎\"],\\n    \"rawText\": \"11/21 山田 太郎 14:00 面談\"\\n  }\\n]\\n\\n例3（日時読み取り困難）:\\n[\\n  {\\n    \"date\": null,\\n    \"startTime\": null,\\n    \"endTime\": null,\\n    \"title\": \"納期未定の打ち合わせ\",\\n    \"description\": \"詳細は未記入\",\\n    \"category\": \"other\",\\n    \"assignedTo\": [],\\n    \"rawText\": \"未定 打ち合わせ\"\\n  }\\n]\\n\\n注: assignedTo が得られない場合でも空の配列を返すこと、rawText には可能な限り元テキスト断片を入れることを徹底してください。` +\n      nameInstruction;\n\n    let message: any | null = null;\n    if (hasAnthropicKey) {\n      try {\n        // Dynamic import to avoid build/runtime issues when package is not\n        // available or cannot be loaded in the target environment.\n        const { default: Anthropic } = await import(\"@anthropic-ai/sdk\");\n        const anthClient = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });\n\n        message = await anthClient.messages.create({\n          model: \"claude-sonnet-4-20250514\",\n          max_tokens: 2000,\n          messages: [\n            {\n              role: \"user\",\n              content: [\n                {\n                  type: \"image\",\n                  source: {\n                    type: \"base64\",\n                    media_type: mimeType as\n                      | \"image/jpeg\"\n                      | \"image/png\"\n                      | \"image/gif\"\n                      | \"image/webp\",\n                    data: base64Data,\n                  },\n                },\n                {\n                  type: \"text\",\n                  text: prompt,\n                },\n              ],\n            },\n          ],\n        });\n      } catch (llmError) {\n        console.error(\"Anthropic import/call error - falling back to Tesseract:\", llmError);\n        message = null;\n      }\n    }\n\n    // レスポンスからテキストを抽出（LLM 経由）または Tesseract フォールバック\n    let schedules: OCRResult[] = [];\n    if (message) {\n      const responseText = message.content\n        .filter((block: any) => block.type === \"text\")\n        .map((block: any) => (block.type === \"text\" ? block.text : \"\"))\n        .join(\"\");\n\n      try {\n        // マークダウンのコードブロックを除去\n        const cleanedText = responseText\n          .replace(/```json\\n?/g, \"\")\n          .replace(/```\\n?/g, \"\")\n          .trim();\n\n        schedules = JSON.parse(cleanedText);\n\n        // 配列でない場合は配列に変換\n        if (!Array.isArray(schedules)) {\n          schedules = [schedules];\n        }\n      } catch (parseError) {\n        console.error(\"JSON parse error from LLM output:\", parseError);\n        schedules = [];\n      }\n    } else {\n      // LLMが使えない／失敗した場合は Tesseract による抽出を試みる\n      try {\n        const ocrText = await performTesseractOCR(base64Data);\n        // 簡易パース: 行ごとに name を含む行を抽出して予定とする\n        const lines = ocrText\n          .split(/\\r?\\n/)\n          .map((l) => l.trim())\n          .filter(Boolean);\n        const nm = name ? name.trim().toLowerCase().replace(/\\s+/g, \"\") : \"\";\n        const normalize = (s: string) => s.toLowerCase().replace(/\\s+/g, \"\");\n        if (nm) {\n          for (const line of lines) {\n            if (normalize(line).includes(nm)) {\n              // try to extract date/time using regex\n              const dateMatch = line.match(\n                /(20\\d{2}[-\\/.]\\d{1,2}[-\\/.]\\d{1,2})|(\\d{1,2}\\/\\d{1,2})/\n              );\n              const timeMatch = line.match(/(\\d{1,2}:\\d{2})/g);\n              const date = dateMatch ? dateMatch[1] || dateMatch[2] : null;\n              const startTime = timeMatch ? timeMatch[0] : null;\n              const endTime =\n                timeMatch && timeMatch.length > 1 ? timeMatch[1] : null;\n              schedules.push({\n                date: date || undefined,\n                startTime: startTime || undefined,\n                endTime: endTime || undefined,\n                title: line,\n                description: \"\",\n                category: \"other\",\n                assignedTo: [name],\n                rawText: line,\n              } as OCRResult);\n            }\n          }\n\n          // 指定名があるのに抽出が0件なら空配列を返す（ユーザー要求に沿う）\n          schedules = schedules || [];\n        } else {\n          // 名前指定なしなら全テキストから1つの候補を返す\n          const firstLine = lines[0] || ocrText;\n          schedules.push({\n            // date/startTime/endTime は未定義にする\n            title: firstLine || \"抽出された予定\",\n            description: \"\",\n            category: \"other\",\n            assignedTo: [],\n            rawText: ocrText,\n          } as OCRResult);\n        }\n      } catch (tessErr) {\n        console.error(\"Tesseract fallback error:\", tessErr);\n        return NextResponse.json<APIResponse<null>>(\n          {\n            success: false,\n            error: \"OCR処理（Tesseract）中にエラーが発生しました\",\n          },\n          { status: 500 }\n        );\n      }\n    }\n\n    // サーバー側でも名前フィルタをかける（クライアントから name が渡されている場合）\n    if (name && name.trim()) {\n      const nmRaw = name.trim();\n\n      const normalize = (s?: string) => {\n        if (!s) return \"\";\n        // 小文字化・空白削除・全角英数字を半角化・正規化\n        const fwToHw = (str: string) =>\n          str\n            .replace(/[\u0001-]/g, (ch) => ch)\n            .replace(/[！-～]/g, (c) =>\n              String.fromCharCode(c.charCodeAt(0) - 0xfee0)\n            );\n        return fwToHw(s)\n          .normalize(\"NFKC\")\n          .toLowerCase()\n          .replace(/\\s+/g, \"\")\n          .replace(/[\\p{P}\\p{S}]/gu, \"\");\n      };\n\n      // レーベンシュタイン距離（簡易実装）\n      const levenshtein = (a: string, b: string) => {\n        const dp: number[][] = Array.from({ length: a.length + 1 }, () =>\n          new Array(b.length + 1).fill(0)\n        );\n        for (let i = 0; i <= a.length; i++) dp[i][0] = i;\n        for (let j = 0; j <= b.length; j++) dp[0][j] = j;\n        for (let i = 1; i <= a.length; i++) {\n          for (let j = 1; j <= b.length; j++) {\n            const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n            dp[i][j] = Math.min(\n              dp[i - 1][j] + 1,\n              dp[i][j - 1] + 1,\n              dp[i - 1][j - 1] + cost\n            );\n          }\n        }\n        return dp[a.length][b.length];\n      };\n\n      const nm = normalize(nmRaw);\n\n      const matchesName = (item: OCRResult) => {\n        // 1) まず assignedTo があればそちらを優先して照合\n        const as = (item as any).assignedTo as string[] | undefined;\n        if (Array.isArray(as) && as.length > 0) {\n          for (const person of as) {\n            const p = normalize(person);\n            if (!p) continue;\n            if (p.includes(nm) || nm.includes(p)) return true;\n            const maxDist = Math.max(\n              1,\n              Math.floor(Math.max(nm.length, p.length) * 0.3)\n            );\n            if (levenshtein(p, nm) <= maxDist) return true;\n          }\n          return false;\n        }\n\n        // 2) 次に title/description/rawText を使って照合\n        const fields = [item.title, item.description, (item as any).rawText]\n          .filter(Boolean)\n          .map((s) => normalize(String(s)));\n\n        for (const f of fields) {\n          if (f.includes(nm) || nm.includes(f)) return true;\n          if (levenshtein(f, nm) <= Math.max(1, Math.floor(nm.length * 0.25)))\n            return true;\n        }\n\n        return false;\n      };\n\n      const filtered = schedules.filter(matchesName);\n\n      // 指示通り、該当がなければ空配列を返す\n      schedules = filtered;\n    }\n\n    return NextResponse.json<APIResponse<OCRResult[]>>({\n      success: true,\n      data: schedules,\n    });\n  } catch (error) {\n    console.error(\"OCR processing error:\", error);\n\n    return NextResponse.json<APIResponse<null>>(\n      {\n        success: false,\n        error: \"OCR処理中にエラーが発生しました\",\n      },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"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"}}]
}